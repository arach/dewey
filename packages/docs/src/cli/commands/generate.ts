import chalk from 'chalk'
import { readdir, readFile, writeFile, access } from 'fs/promises'
import { join } from 'path'
import matter from 'gray-matter'
import { loadConfig } from '../config.js'

interface GenerateOptions {
  output?: string
  agentsMd?: boolean
  llmsTxt?: boolean
  docsJson?: boolean
  installMd?: boolean
}

interface DocSection {
  id: string
  title: string
  description?: string
  content: string
  order: number
}

async function fileExists(path: string): Promise<boolean> {
  try {
    await access(path)
    return true
  } catch {
    return false
  }
}

async function loadDocs(docsPath: string, sections: string[]): Promise<DocSection[]> {
  const docs: DocSection[] = []

  for (const section of sections) {
    const filePath = join(docsPath, `${section}.md`)
    if (!await fileExists(filePath)) continue

    const content = await readFile(filePath, 'utf-8')
    const { data: frontmatter, content: body } = matter(content)

    docs.push({
      id: section,
      title: (frontmatter.title as string) || section.charAt(0).toUpperCase() + section.slice(1),
      description: frontmatter.description as string | undefined,
      content: body.trim(),
      order: (frontmatter.order as number) || 999,
    })
  }

  // Sort by order
  docs.sort((a, b) => a.order - b.order)

  return docs
}

function generateAgentsMd(projectName: string, tagline: string | undefined, config: Awaited<ReturnType<typeof loadConfig>>, docs: DocSection[]): string {
  if (!config) return ''

  const lines: string[] = []

  // Header
  lines.push(`# ${projectName}`)
  lines.push('')
  if (tagline) {
    lines.push(`> ${tagline}`)
    lines.push('')
  }

  // Critical context
  if (config.agent.criticalContext.length > 0) {
    lines.push('## Critical Context')
    lines.push('')
    lines.push('**IMPORTANT:** Read these rules before making any changes:')
    lines.push('')
    for (const rule of config.agent.criticalContext) {
      lines.push(`- ${rule}`)
    }
    lines.push('')
  }

  // Project structure / entry points
  if (Object.keys(config.agent.entryPoints).length > 0) {
    lines.push('## Project Structure')
    lines.push('')
    lines.push('| Component | Path | Purpose |')
    lines.push('|-----------|------|---------|')
    for (const [name, path] of Object.entries(config.agent.entryPoints)) {
      const displayName = name.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ')
      lines.push(`| ${displayName} | \`${path}\` | |`)
    }
    lines.push('')
  }

  // Navigation rules
  if (config.agent.rules.length > 0) {
    lines.push('## Quick Navigation')
    lines.push('')
    for (const rule of config.agent.rules) {
      lines.push(`- Working with **${rule.pattern}**? â†’ ${rule.instruction}`)
    }
    lines.push('')
  }

  // Documentation sections
  for (const doc of docs) {
    lines.push(`## ${doc.title}`)
    lines.push('')
    if (doc.description) {
      lines.push(`> ${doc.description}`)
      lines.push('')
    }
    lines.push(doc.content)
    lines.push('')
  }

  // Footer
  lines.push('---')
  lines.push(`Generated by [Dewey](https://github.com/arach/dewey) | Last updated: ${new Date().toISOString().split('T')[0]}`)

  return lines.join('\n')
}

function generateLlmsTxt(projectName: string, tagline: string | undefined, docs: DocSection[]): string {
  const lines: string[] = []

  lines.push(`# ${projectName}`)
  lines.push('')
  if (tagline) {
    lines.push(`> ${tagline}`)
    lines.push('')
  }

  lines.push('## Documentation')
  lines.push('')
  for (const doc of docs) {
    lines.push(`- ${doc.title}: /docs/${doc.id}`)
  }
  lines.push('')

  // Summary of each section
  for (const doc of docs) {
    lines.push(`## ${doc.title}`)
    lines.push('')
    // Find first non-heading paragraph with actual content
    const paragraphs = doc.content.split('\n\n')
    for (const para of paragraphs) {
      // Strip any headings from the paragraph
      const content = para.replace(/^#+\s+.+$/gm, '').trim()
      if (content) {
        lines.push(content)
        lines.push('')
        break
      }
    }
  }

  return lines.join('\n')
}

function generateDocsJson(projectName: string, version: string | undefined, docs: DocSection[]): string {
  const data = {
    project: projectName,
    version: version || '0.0.0',
    generatedAt: new Date().toISOString(),
    sections: docs.map(doc => ({
      id: doc.id,
      title: doc.title,
      description: doc.description,
      content: doc.content,
    })),
  }

  return JSON.stringify(data, null, 2)
}

/**
 * Generate install.md following the installmd.org standard
 * @see https://installmd.org
 */
function generateInstallMd(config: Awaited<ReturnType<typeof loadConfig>>, docs: DocSection[]): string {
  if (!config) return ''

  const lines: string[] = []
  const projectName = config.project.name.toLowerCase().replace(/\s+/g, '-')
  const install = config.install

  // H1 with lowercase hyphenated name
  lines.push(`# ${projectName}`)
  lines.push('')

  // Blockquote description
  if (config.project.tagline) {
    lines.push(`> ${config.project.tagline}`)
    lines.push('')
  }

  // Agent instruction
  lines.push(`You are an expert at installing ${config.project.name}. Execute these steps autonomously`)
  lines.push('and inform the user of any decisions made. Request approval before running')
  lines.push('installation commands.')
  lines.push('')

  // OBJECTIVE section
  lines.push('## OBJECTIVE')
  lines.push('')
  if (install?.objective) {
    lines.push(install.objective)
  } else {
    lines.push(`Install and configure ${config.project.name}.`)
  }
  lines.push('')

  // DONE WHEN section
  lines.push('## DONE WHEN')
  lines.push('')
  if (install?.doneWhen) {
    lines.push(`\`${install.doneWhen.command}\`${install.doneWhen.expectedOutput ? ` returns ${install.doneWhen.expectedOutput}` : ' completes successfully'}`)
  } else {
    // Try to infer from project type
    switch (config.project.type) {
      case 'npm-package':
        lines.push(`\`npm list ${projectName}\` shows the package installed.`)
        break
      case 'cli-tool':
        lines.push(`\`${projectName} --version\` returns a version number.`)
        break
      case 'macos-app':
        lines.push(`The app is installed in /Applications and can be launched.`)
        break
      default:
        lines.push(`Installation completes without errors.`)
    }
  }
  lines.push('')

  // TODO section (checklist)
  lines.push('## TODO')
  lines.push('')
  if (install?.steps && install.steps.length > 0) {
    for (const step of install.steps) {
      lines.push(`- [ ] ${step.description}`)
    }
  } else {
    // Default steps based on project type
    lines.push('- [ ] Verify prerequisites')
    lines.push('- [ ] Install the package')
    if (config.project.type !== 'npm-package') {
      lines.push('- [ ] Configure initial settings')
    }
    lines.push('- [ ] Verify installation')
  }
  lines.push('')

  // Prerequisites section (if any)
  if (install?.prerequisites && install.prerequisites.length > 0) {
    lines.push('## Prerequisites')
    lines.push('')
    for (const prereq of install.prerequisites) {
      lines.push(`- ${prereq}`)
    }
    lines.push('')
  }

  // Detailed step sections
  if (install?.steps && install.steps.length > 0) {
    install.steps.forEach((step, index) => {
      lines.push(`## Step ${index + 1}: ${step.description}`)
      lines.push('')
      if (step.command) {
        lines.push('```bash')
        lines.push(step.command)
        lines.push('```')
        lines.push('')
      }
      if (step.alternatives && step.alternatives.length > 0) {
        for (const alt of step.alternatives) {
          lines.push(`**Alternative for ${alt.condition}:**`)
          lines.push('```bash')
          lines.push(alt.command)
          lines.push('```')
          lines.push('')
        }
      }
    })
  } else {
    // Generate default steps from quickstart doc if available
    const quickstart = docs.find(d => d.id === 'quickstart')
    if (quickstart) {
      lines.push('## Installation')
      lines.push('')
      // Extract installation section from quickstart if possible
      const installMatch = quickstart.content.match(/## Installation[\s\S]*?(?=##|$)/)
      if (installMatch) {
        lines.push(installMatch[0].replace('## Installation', '').trim())
      } else {
        // Fallback based on project type
        switch (config.project.type) {
          case 'npm-package':
          case 'react-library':
            lines.push('```bash')
            lines.push('# Using pnpm (recommended)')
            lines.push(`pnpm add ${projectName}`)
            lines.push('')
            lines.push('# Using npm')
            lines.push(`npm install ${projectName}`)
            lines.push('')
            lines.push('# Using yarn')
            lines.push(`yarn add ${projectName}`)
            lines.push('```')
            break
          case 'cli-tool':
            lines.push('```bash')
            lines.push('# Using pnpm')
            lines.push(`pnpm add -g ${projectName}`)
            lines.push('')
            lines.push('# Using npm')
            lines.push(`npm install -g ${projectName}`)
            lines.push('```')
            break
          case 'macos-app':
            lines.push('```bash')
            lines.push('# Using Homebrew')
            lines.push(`brew install --cask ${projectName}`)
            lines.push('')
            lines.push('# Or build from source')
            lines.push('swift build -c release')
            lines.push('```')
            break
          default:
            lines.push('See documentation for installation instructions.')
        }
      }
      lines.push('')
    }
  }

  // EXECUTE NOW section
  lines.push('## EXECUTE NOW')
  lines.push('')
  lines.push('Proceed with installation following the TODO checklist above.')
  lines.push('')

  // Footer
  lines.push('---')
  lines.push(`Generated by [Dewey](https://github.com/arach/dewey) | [installmd.org](https://installmd.org)`)

  return lines.join('\n')
}

export async function generateCommand(options: GenerateOptions) {
  const cwd = process.cwd()
  const config = await loadConfig(cwd)

  if (!config) {
    console.log(chalk.red('\nâŒ No dewey.config.ts found. Run') + chalk.cyan(' dewey init ') + chalk.red('first.\n'))
    process.exit(1)
  }

  const docsPath = join(cwd, config.docs.path)
  const outputPath = options.output || join(cwd, config.docs.output)

  if (!await fileExists(docsPath)) {
    console.log(chalk.red(`\nâŒ Docs directory not found: ${config.docs.path}\n`))
    process.exit(1)
  }

  console.log(chalk.blue(`\nðŸ”„ Generating agent files for ${config.project.name}...\n`))

  // Get all available sections
  const files = await readdir(docsPath)
  const availableSections = files
    .filter(f => f.endsWith('.md'))
    .map(f => f.replace('.md', ''))

  // Filter to configured sections (or use all if not specified)
  const sectionsToInclude = config.agent.sections.length > 0
    ? config.agent.sections.filter(s => availableSections.includes(s))
    : availableSections

  const docs = await loadDocs(docsPath, sectionsToInclude)

  // Determine which files to generate
  const generateAll = !options.agentsMd && !options.llmsTxt && !options.docsJson && !options.installMd
  const filesToGenerate = {
    agentsMd: generateAll || options.agentsMd,
    llmsTxt: generateAll || options.llmsTxt,
    docsJson: generateAll || options.docsJson,
    installMd: generateAll || options.installMd,
  }

  // Generate AGENTS.md
  if (filesToGenerate.agentsMd) {
    const content = generateAgentsMd(
      config.project.name,
      config.project.tagline,
      config,
      docs
    )
    const filePath = join(outputPath, 'AGENTS.md')
    await writeFile(filePath, content)
    console.log(chalk.green('âœ“') + ` Generated ${chalk.cyan('AGENTS.md')}`)
  }

  // Generate llms.txt
  if (filesToGenerate.llmsTxt) {
    const content = generateLlmsTxt(
      config.project.name,
      config.project.tagline,
      docs
    )
    const filePath = join(outputPath, 'llms.txt')
    await writeFile(filePath, content)
    console.log(chalk.green('âœ“') + ` Generated ${chalk.cyan('llms.txt')}`)
  }

  // Generate docs.json
  if (filesToGenerate.docsJson) {
    const content = generateDocsJson(
      config.project.name,
      config.project.version,
      docs
    )
    const filePath = join(outputPath, 'docs.json')
    await writeFile(filePath, content)
    console.log(chalk.green('âœ“') + ` Generated ${chalk.cyan('docs.json')}`)
  }

  // Generate install.md (installmd.org standard)
  if (filesToGenerate.installMd) {
    const content = generateInstallMd(config, docs)
    const filePath = join(outputPath, 'install.md')
    await writeFile(filePath, content)
    console.log(chalk.green('âœ“') + ` Generated ${chalk.cyan('install.md')} (installmd.org standard)`)
  }

  console.log(chalk.blue('\nâœ¨ Agent files generated!\n'))
  console.log(`Output directory: ${chalk.gray(outputPath)}`)
  console.log(`Included sections: ${chalk.gray(sectionsToInclude.join(', '))}`)
  console.log()
}
